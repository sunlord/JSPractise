## ES5

### 作用域

​	对象有属性，那么一切为对象的东西都可以有属性

​	每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供javascript引擎存取。

​	[[scope]]就是我们所说的作用域，存储了作用域链（scope chain），其中存储了执行期上下文的集合

​		执行期上下文：当函数执行时（预编译，前一刻），会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的。所以多次调用一个函数会导致创建多个执行期上下文。当函数执行完毕时，他所产生的执行期上下文被销毁。

函数执行时，函数的AO（Activation Object）被放在作用域链的第0位；GO（Global Object）被放在作用域链的第1位。

查找变量时：在此函数的作用域链内依次向下查找。

​	函数a内部另一个函数b的AO来自于上一层函数a的AO。



### 闭包

​	在函数a执行完毕时，返回函数a内的函数b，同时销毁函数a的AO，但此时函数a的AO被函数b的AO引用，因此只能断开函数a的AO指向，但不能销毁函数a的AO。

​	在函数a销毁时，函数b还未被执行，只是被定义，因此拥有函数a的AO和全局的GO。

闭包的危害： 当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄露（内存占用）。避免无意造成闭包，拖慢运行速度。

闭包的作用： 

	实现公有变量： 函数累加器。count++，执行一次加一次，统计函数调用次数。
	可以做缓存（存储结构）。 
	可以实现封装，属性私有化
	模块化开发，防止污染全局变量



### 立即执行函数

​	针对初始化功能的函数。

​	执行完立即销毁。

​	函数名在执行完后会被销毁，起不起函数名都不会保存，因此函数名直接省略不写。

​	两种写法： (function () {}());	W3C建议使用此种格式。

​						(function () {})();



	### 函数

​	只有表达式才能被执行符号执行。 test();

​	

​																var test = function () {

​																	var a = 1;	

​																}() // 这个叫做函数表达式，可以被执行；

​	

​																function test () {

​																	}(); //这个叫做函数声明，不可被执行。

​	当函数被放在函数表达式时，加()意味着立即执行，执行完后销毁，不再有效。



​	+/-/! function test () {

​		console.log('a');

​	}() //可被执行，控制台打印a；



function test () {

​	console.log(a);

}(); //报错



function test (a) {

​	console.log(a);

}(1);  //不报错也不执行



函数被执行时，内部内容才被读取执行。

​	

## ES6：

​	

​	1.

​	var: 函数级的作用域

​	

​	2.

​    let: 块级作用域(花括号级作用域)

​    let: 不存在变量提升

​    let: 不允许重复声明

​	

​	3.

​    const: 声明一个只读的常量,声明之后不允许再改变

​    const: 声明的时候必须直接初始化

​    const: 块级作用域,和let相当

​	const: 不存在变量提升

​	const: 不能重复声明



​	4.变量的解构赋值

​	利用解构赋值的方式简化

​    对象的属性没有次序,但变量必须与属性同名,才能取到正确的值

​	例： 

​		var i = 10;

​		console.log(i)

​		{ log } = console;

​		log(i);

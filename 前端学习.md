## ES5

### 作用域

​	对象有属性，那么一切为对象的东西都可以有属性

​	每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供javascript引擎存取。

​	[[scope]]就是我们所说的作用域，存储了作用域链（scope chain），其中存储了执行期上下文的集合

​		执行期上下文：当函数执行时（预编译，前一刻），会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的。所以多次调用一个函数会导致创建多个执行期上下文。当函数执行完毕时，他所产生的执行期上下文被销毁。

函数执行时，函数的AO（Activation Object）被放在作用域链的第0位；GO（Global Object）被放在作用域链的第1位。

查找变量时：在此函数的作用域链内依次向下查找。

​	函数a内部另一个函数b的AO来自于上一层函数a的AO。



### 闭包

​	在函数a执行完毕时，返回函数a内的函数b，同时销毁函数a的AO，但此时函数a的AO被函数b的AO引用，因此只能断开函数a的AO指向，但不能销毁函数a的AO。

​	在函数a销毁时，函数b还未被执行，只是被定义，因此拥有函数a的AO和全局的GO。

闭包的危害： 当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄露（内存占用）。避免无意造成闭包，拖慢运行速度。

闭包的作用： 

	实现公有变量： 函数累加器。count++，执行一次加一次，统计函数调用次数。
	可以做缓存（存储结构）。 
	可以实现封装，属性私有化
	模块化开发，防止污染全局变量



### 立即执行函数

​	针对初始化功能的函数。

​	执行完立即销毁。

​	函数名在执行完后会被销毁，起不起函数名都不会保存，因此函数名直接省略不写。

​	两种写法： (function () {}());	W3C建议使用此种格式。

​						(function () {})();



	### 函数

​	只有表达式才能被执行符号执行。 test();

​	

​																var test = function () {

​																	var a = 1;	

​																}() // 这个叫做函数表达式，可以被执行；

​	

​																function test () {

​																	}(); //这个叫做函数声明，不可被执行。

​	当函数被放在函数表达式时，加()意味着立即执行，执行完后销毁，不再有效。



​	+/-/! function test () {

​		console.log('a');

​	}() //可被执行，控制台打印a；



function test () {

​	console.log(a);

}(); //报错



function test (a) {

​	console.log(a);

}(1);  //不报错也不执行



函数被执行时，内部内容才被读取执行。



if(function f () {} ) {};  == > if()内的条件，判断完后销毁，f不再被定义。typeof f 为undefined。



### 逗号操作符

​	var a = (2, 3);   == > 先进行括号内前面的运算，然后将后面的值返回给a。

​	var a = (1 - 1, 1 + 1) ; == > 返回值为2。



### 对象

对象的创建方法： 

	1. var obj = {}  plainObject 对象字面量 / 对象直接量
	2. 构造函数
	 	1. 系统自带的构造函数 Object() Array() Number()
	 	2. 自定义的 

​		var obj = new Object(); 

​		var obj = {};  和上面一样，并没有区别。推荐使用此种方法。对象字面量。

> 构造函数和普通函数形式上没有任何区别。

> > 但是构造函数必须有一个操作符：new

>  function Person () {} --> var person1 = new Person();

> 构造函数在命名时必须严格遵循大驼峰式命名规则 TheFirstName！

构造函数内部原理： (三步)

	1. 在函数体最前面隐式的加上this = {};
	1. 执行this.xxx = xxx;
	1. 隐式的返回this;

原始值不能有属性和对象。但对象number可以有属性和对象。

var num = 123; num.abc //报错

var num =new Number (123); num.abc = 'a' 对的

var str = new String ('abcd');

var bol = new Boolean();



> Undefined null 这两个不能有属性

### 包装类

var num = 4;

num.len = 3; //new Number(4).len = 3; delete

console.log(num.len); //new Number(4).len; 新创建了一个构造函数，这个隐式的过程被称为包装类。

> var str = 'abcd';
>
> str.length = 2; //new String ('abcd').length = 2; delete;
>
> console.log(str); // 输出abcd

### 原型。

Person.prototype = {} 是祖先

function Person() {

}

Var person = new Person();

> 原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。
>
> 通过该构造函数产生的对象，可以继承该原型的属性和方法。
>
> 原型也是对象。
>
> 利用原型特点和概念，可以提取共有属性。

constructor： 构造函数，指向来源。可以改变。



隐式属性 __proto__：

function Person() {
    //this = {
    //  __proto__ : Person.prototype
    //}
  }

有proto的存在，才能让new的新函数沿着链条向上找到Person.prototype。proto可以更改。

Function obj () {

}

person.__proto__ = obj;

### 原型链

Person.prototype.__proto__ = Object.prototype 所有构造函数的终端

终端也没有，就是undefined。

Object.create(原型)

原型是一个隐式的内部的东西，自己加系统无法读取。

绝大多数对象最终都会继承制Object.prototype。（除了Object.create(原型)）。



Document.write(obj);和 alert(obj); 会隐式的调用一个obj.toString(); 

​	> var obj = Object.create(null);

​	> obj.toString = function () {

​			return 'hello world';

​		}

​		document.write(obj); // 打印‘hello world'。

​		alert(obj);                   // 弹出’hello world'

### javascript精度问题

尽量避免小数操作。如果一定要操作，则：

​	Math.ceil(123.234)向上取整 输出： 124。

​	Math.floor(123.234)上下取整 输出: 123。

​	Math.random() 随机数，输出 0 - 1之间的随机数（不包括0和1）。

​	toFixed(2) 保留两位小数。

​	解决方法：Math.floor(Math.random() * 100); 先乘100，再取整。

​	> javascript 可正常计算的范围是小数点前16位，小数点后16位。

### Call

test(); ==> test.call();内部隐式做了一次这样的调用。

Call(),改变this指向。完全覆盖其他函数的需求，则可以用call()引用复写。

### Apply

apply后面必须传数组。

Test.call(this,...);    需要把实参按照形参的个数传进去。

test.apply(this, [arguments]); 需要传一个arguments。

call/appy: 作用： 改变this指向。

​				 区别：传参列表不同。



### 继承

extends / inherit

	1. 传统形式 ==> 原型链 （过多继承无用的东西，不推荐）
	2. 借用构造函数 。 缺点：
	 	1. 不能继承借用构造函数的原型
	 	2. 每次构造函数都要多走一个函数
	1. 共享原型 / 公有原型

​	>           function inherit (Target, Origin) {

>   Target.prototype = Origin.protorype;
> 	  } 

​	            Inherit();

​				缺点： 子函数加原型就会影响父函数的原型。



4. 圣杯模式

```圣杯模式
function inherit (Target, Origin) {
	function F () {};
	F.prototype = Origin.prototype;
	Target.prototype = new F();
	Target.prototype.constructor = Target;
  Target.prototype.uber = Origin.prototype;
}
inherit(Son, Father);
```
>  以下是更好的圣杯模式：

var inherit = (function () {
    var F = function () {};
    return function (Target, Origin) {
      F.prototype = Origin.prototype;
      Target.prototype = new F();
      Target.prototype.constructor = Target;
      Target.prototype.uber = Origin.prototype;
    }
  }());

### 拼接调用

name1 = 'xxx',

name2 = 'xxx', 

name3 = 'xxx',

sayName (num) {

​	return obj['name' + num];	

}

obj.name ---> obj['name']内部隐式的调用。但要注意，obj[ ]内部必须是字符串形式。

on + click; on + mouse;等例子。

### 遍历属性 in

var prop in obj

var obj = {
    name: '12',
    age: 123,
    sex: 'male',
    height: 180
  } 

  for (var prop in obj) {
    document.write(prop + ':' + obj[prop] + ' ' + typeof(obj[prop]) + ' ');
  }

obj[prop]不可以写成obj.prop; 

​			也不可以写成obj['prop'];

寻找到原型链最顶端时，不再访问。但如果是自己手动添加的原型上的属性，即使是Object.prototype上的属性，也会被拿出来。

判断是否是自己的属性还是原型及原型链上的东西，用obj.hasOwnProperty(prop)判断，返回boolean值 true / false。

'name' in obj结果也是一个判断，返回true / false。并且会把原型链上的都拿来判断。

### instanceof

A instanceof B 判断 A 对象 是不是 B 构造函数 构造出来的

​	返回值为 true / false。

[ ] instanceof Object true;

我们应该理解为： 看 A 对象的原型链上 有没有 B 的原型。



#### 判断是对象还是数组的三种方法

1. var arr = [ ];

   arr.constructor -- > Object Array

2. Var arr = [ ];

​		arr instanceof Array  -- > true / arr instanceof Object -- > false 

​		

3. Var obj = { }

​	Object.prototype.toString.call(obj); -- > object object;

​	Object.prototype.toString.call([ ]); -- > object Array;

toString 可以跨父子域，instanceof 和 constructor不可以。

#### ==

引用值比的是地址。地址相同，==就相同，===也相同。

### this

1. 函数预编译过程中，this指向window

​	AO {

​		arguments:[1],

​		this: window,

​		c: 1,

​		a: undefined,

​		b: function () {}

​	}	//预编译过程

​	test(1);



2. 全局作用域里，this指向window
3. call/apply 可以改变函数运行时this指向
4. obj调用obj.func(),this就指向obj。

#### Arguments.callee 

-- > 指向函数自身引用。

#### function.caller

​	function test () {

​		demo();

​	}

​	function demo () {

​		conosole.log(demo.caller);	

​	}

​	test(); //caller指向test(); 

严格模式下，callee和caller不能用。

### 数组

创建方法： 

	1. var arr = [ ];
	1. var arr = new Array();

区别： var arr = new Array(10); 长度为10的空数组。 var arr = [10]；长度为1。

​			var arr = new Array(10.2);这个是错误的，识别为10.2长度，非法长度。









## ES6：

​	

​	1.

​	var: 函数级的作用域

​	

​	2.

​    let: 块级作用域(花括号级作用域)

​    let: 不存在变量提升

​    let: 不允许重复声明

​	

​	3.

​    const: 声明一个只读的常量,声明之后不允许再改变

​    const: 声明的时候必须直接初始化

​    const: 块级作用域,和let相当

​	const: 不存在变量提升

​	const: 不能重复声明



​	4.变量的解构赋值

​	利用解构赋值的方式简化

​    对象的属性没有次序,但变量必须与属性同名,才能取到正确的值

​	例： 

​		var i = 10;

​		console.log(i)

​		{ log } = console;

​		log(i);
